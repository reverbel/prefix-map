import ceylon.collection {
    MutableMap,
    MutableList,
    ArrayList
}

"Minimum length (in `Character`s) of an `Element`, in the output 
 generated by `someTernaryTree.printNodes()`."
variable Integer paddedElementSize = 1;

"Minimum length (in `Character`s) of an `Item`, in the output 
 generated by `someTernaryTree.printNodes()`."
variable Integer paddedItemSize = 6;


shared class TreeNode<KeyElement, Item>(
    shared KeyElement element,
    shared variable Item? item, 
    shared variable TreeNode<KeyElement, Item>? left,
    shared variable TreeNode<KeyElement, Item>? middle,
    shared variable TreeNode<KeyElement, Item>? right,
    shared variable Boolean terminal)
        given KeyElement satisfies Object {
    
    shared TreeNode<KeyElement, Item> deepCopy() {
        value copy = TreeNode<KeyElement, Item> {
            element = this.element;
            item = this.item;
            left = null;
            middle = null;
            right = null;
            terminal = this.terminal;
        };
        if (exists l = left) {
            copy.left = l.deepCopy();
        }
        if (exists m = middle) {
            copy.middle = m.deepCopy();
        }
        if (exists r = right) {
            copy.right = r.deepCopy();
        }
        return copy;
    }
    
    shared Integer size {
        variable Integer size = if (terminal) then 1 else 0;
        if (exists l = left) {
            size += l.size;
        }
        if (exists m = middle) {
            size += m.size;
        }
        if (exists r = right) {
            size += r.size;
        }
        return size;
    }
    
    String id =>
            "Node@``hash.string.padLeading(10, '_')``";
    
    shared actual String string {
        value sBuilder = StringBuilder();
        sBuilder.append(id)
                .append(": ")
                .append(element.string.padLeading(paddedElementSize))
                .append(", ")
                .append(item?.string?.padLeading(paddedItemSize) else "<null>")
                .append(", ")
                .append(left?.id else "  no left child")
                .append(", ")
                .append(middle?.id else "no middle child")
                .append(", ")
                .append(right?.id else " no right child");
        if (terminal) {
            sBuilder.append(", T");
        }
        return sBuilder.string;
    }
}

shared abstract class AbstractTernaryTree<KeyElement, Item>()
        satisfies PrefixMap<KeyElement, Item> 
                  & MutableMap<[KeyElement+], Item> 
        given KeyElement satisfies Comparable<KeyElement> {
    
    shared class Node(KeyElement element,
                      Item? item, 
                      TreeNode<KeyElement, Item>? left,
                      TreeNode<KeyElement, Item>? middle,
                      TreeNode<KeyElement, Item>? right,
                      Boolean terminal) 
            => TreeNode<KeyElement, Item>(element, item, left, 
                                          middle, right, terminal);

    "The root node of the tree."
    shared formal variable Node? root;

    "A comparator function used to sort the entries."
    shared formal Comparison(KeyElement, KeyElement) compare;
    
    //shared actual formal Item? put(Key key, Item item);

    //shared actual formal Item? remove(Key key);
    
    //shared actual formal AbstractTernaryTree<KeyElement, Item> clone();
    
    shared formal Node? search(Key key, Node? node);
    
    Node? lookup(Key key, Node? startingNode = root)
            => let (node = search(key, startingNode))
               if (exists node, node.terminal) then node else null; 
    
    shared actual Item? get(Object key)
            => if (is Key key) 
               then lookup(key)?.item 
               else find(forKey(key.equals))?.item;
    
    shared actual Boolean defines(Object key)
            => if (is Key key) 
               then lookup(key) exists 
               else keys.any(key.equals);
    
    // Puts in the given `queue` all the entries with the given 
    // `keyPrefix` in the subtree rooted at the given `node`. 
    // The entries are enqueued in lexicographic order of keys, 
    // from the smallest to the largest key.  
    shared void enumerateEntries(Node? node, 
                                 MutableList<KeyElement> keyPrefix, 
                                 MutableList<Key->Item> queue) {
        if (exists node) {
            // left subtree:
            enumerateEntries(node.left, keyPrefix, queue);
            
            // middle subtree:
            keyPrefix.add(node.element);
            if (node.terminal) {
                assert (nonempty k = [ for (e in keyPrefix) e ]);
                assert (exists i = node.item);
                queue.add(k->i);
            }
            enumerateEntries(node.middle, keyPrefix, queue);
            keyPrefix.deleteLast();
            
            // right subtree:       
            enumerateEntries(node.right, keyPrefix, queue);
        }
    }
    
    shared actual Iterator<Key->Item> iterator() {
        value queue = ArrayList<Key->Item>();
        enumerateEntries(root, ArrayList<KeyElement>(), queue);
        return queue.iterator();
    }
    
    Node? subtree(Key prefix) 
            => search(prefix, root); 
    
    shared actual Boolean hasKeyWithPrefix(Object prefix)
            => if (is Key prefix) then (subtree(prefix) exists) else false;
    
    
    shared actual {Key*} keysWithPrefix(Object prefix)
            => entriesWithPrefix(prefix).map(Entry.key);
    
    shared actual {<Key->Item>*} entriesWithPrefix(Object prefix) {
        if (is Key prefix, exists node = subtree(prefix)) {
            value queue = ArrayList<Key->Item>();
            if (node.terminal) {
                assert (is Item i = node.item);
                queue.add(prefix->i);
            }
            enumerateEntries(node.middle, 
                ArrayList<KeyElement> { elements = prefix; }, 
                queue);
            return queue;
        }
        else {
            return {};
        }
    }
    
    shared actual void clear() 
            => root = null;
    
    shared actual Integer size 
            => root?.size else 0;
    
    shared actual Boolean equals(Object that) 
            => (super of Map<Key,Item>).equals(that);
    
    shared actual Integer hash 
            => (super of Map<Key,Item>).hash;
    
    // begin TODO section
        
    shared actual {<Key->Item>*} ascendingEntries(Key from, Key to) => nothing;
    
    shared actual {<Key->Item>*} descendingEntries(Key from, Key to) => nothing;
    
    shared actual {<Key->Item>*} higherEntries(Key key) => nothing;
    
    shared actual {<Key->Item>*} lowerEntries(Key key) => nothing;
    
    shared actual PrefixMap<KeyElement,Item> measure(Key from, Integer length) => nothing;
    
    shared actual PrefixMap<KeyElement,Item> span(Key from, Key to) => nothing;
    
    shared actual PrefixMap<KeyElement,Item> spanFrom(Key from) => nothing;
    
    shared actual PrefixMap<KeyElement,Item> spanTo(Key to) => nothing;
    
    // end TODO section
    
    void printSubtree(Node? n) {
        if (exists n) {
            print(n);
            printSubtree(n.left);
            printSubtree(n.middle);
            printSubtree(n.right);
        }
    }
    
    "Prints a series of lines to the standart output of the virtual machine
     process, with one line per node of this tree. Each line has the format
     ~~~Text
     Node@<nnnnnnnn>: <element>, <item>, <left child>, <middle child>, <right child>, T
     ~~~
     or the format
     ~~~Text
     Node@<nnnnnnnn>: <element>, <item>, <left child>, <middle child>, <right child>
     ~~~
         
     - The field `<nnnnnnnn>` is the `hash` of the node, left padded 
       with `'_'` characters to a minimum lenght of 10 characteres. 
     - The field `<element>` is the string representation of the 
       `KeyElement` in the node. 
     - The field `<item>` is the string representation of the `Item`
       in the node, or `<null>` if there is no `Item` in the node.
     - The fields `<left child>`, `<middle child>,` and `<right child>`
       identify the corresponding child nodes. Each of these fields has
       the format `Node@<nnnnnnnn>` if the corresponding child node 
       exists, otherwise it contains the text `no left child` (in the 
       case of a missing left child), or the text `no middle child` (in 
       the case of a missing middle child), or the text `no right child`
       (in the case of a missing right child).
     - Lines with the first format (with an ending \`'T'\`) represent 
       terminal nodes, lines with the second format represent nonterminal 
       nodes. 
        
     The example below shows a section of the output produced by a call to
     `printNodes` on a `TernaryTreeMap<Character, Integer>`.   
     ~~~Text
     Node@_596706728: b, <null>, Node@2106900153, Node@1070501849, Node@1298146757  
     Node@2106900153: a, <null>,   no left child, Node@1443055846,  no right child  
     Node@1443055846: t,      2, Node@_502838712, no middle child,  no right child, T
     Node@_502838712: s,      2,   no left child, no middle child,  no right child, T     
     ~~~
     
     This method is intended mainly for debugging purposes."
    shared void printNodes(
        "Minimum length (in `Character`s) of an `Element`, in the output
         generated by [[printNodes]]."
        Integer paddedElementLength = 1, 
        "Minimum length (in `Character`s) of an `Item`, in the output
         generated by [[printNodes]]."
        Integer paddedItemLength = 6) {
        paddedElementSize = paddedElementLength;
        paddedItemSize = paddedItemLength;
        printSubtree(root);     
    }
    
}